(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('prop-types'), require('react'), require('react-dom/server')) :
  typeof define === 'function' && define.amd ? define(['exports', 'prop-types', 'react', 'react-dom/server'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactSVG = {}, global.PropTypes, global.React, global.ReactDOMServer));
}(this, (function (exports, PropTypes, React, ReactDOMServer) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var ReactDOMServer__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOMServer);

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  var objectWithoutPropertiesLoose = _objectWithoutPropertiesLoose;

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var inheritsLoose = _inheritsLoose;

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
      return r;
  }

  /*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
   *
   * parameter     = token "=" ( token / quoted-string )
   * token         = 1*tchar
   * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
   *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
   *               / DIGIT / ALPHA
   *               ; any VCHAR, except delimiters
   * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
   * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
   * obs-text      = %x80-FF
   * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
   */
  var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;

  /**
   * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
   *
   * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
   * obs-text    = %x80-FF
   */
  var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;

  /**
   * RegExp to match type in RFC 7231 sec 3.1.1.1
   *
   * media-type = type "/" subtype
   * type       = token
   * subtype    = token
   */
  var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  var parse_1 = parse;

  /**
   * Parse media type to object.
   *
   * @param {string|object} string
   * @return {Object}
   * @public
   */

  function parse (string) {
    if (!string) {
      throw new TypeError('argument string is required')
    }

    // support req/res-like objects as argument
    var header = typeof string === 'object'
      ? getcontenttype(string)
      : string;

    if (typeof header !== 'string') {
      throw new TypeError('argument string is required to be a string')
    }

    var index = header.indexOf(';');
    var type = index !== -1
      ? header.substr(0, index).trim()
      : header.trim();

    if (!TYPE_REGEXP.test(type)) {
      throw new TypeError('invalid media type')
    }

    var obj = new ContentType(type.toLowerCase());

    // parse parameters
    if (index !== -1) {
      var key;
      var match;
      var value;

      PARAM_REGEXP.lastIndex = index;

      while ((match = PARAM_REGEXP.exec(header))) {
        if (match.index !== index) {
          throw new TypeError('invalid parameter format')
        }

        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];

        if (value[0] === '"') {
          // remove quotes and escapes
          value = value
            .substr(1, value.length - 2)
            .replace(QESC_REGEXP, '$1');
        }

        obj.parameters[key] = value;
      }

      if (index !== header.length) {
        throw new TypeError('invalid parameter format')
      }
    }

    return obj
  }

  /**
   * Get content-type from req/res objects.
   *
   * @param {object}
   * @return {Object}
   * @private
   */

  function getcontenttype (obj) {
    var header;

    if (typeof obj.getHeader === 'function') {
      // res-like
      header = obj.getHeader('content-type');
    } else if (typeof obj.headers === 'object') {
      // req-like
      header = obj.headers && obj.headers['content-type'];
    }

    if (typeof header !== 'string') {
      throw new TypeError('content-type header is missing from object')
    }

    return header
  }

  /**
   * Class to represent a content type.
   * @private
   */
  function ContentType (type) {
    this.parameters = Object.create(null);
    this.type = type;
  }

  var cloneSvg = function cloneSvg(sourceSvg) {
    return sourceSvg.cloneNode(true);
  };

  var isLocal = function isLocal() {
    return window.location.protocol === 'file:';
  };

  var makeAjaxRequest = function makeAjaxRequest(url, callback) {
    var httpRequest = new XMLHttpRequest();

    httpRequest.onreadystatechange = function () {
      try {
        if (!/\.svg/i.test(url) && httpRequest.readyState === 2) {
          var contentType = httpRequest.getResponseHeader('Content-Type');

          if (!contentType) {
            throw new Error('Content type not found');
          }

          var type = parse_1(contentType).type;

          if (!(type === 'image/svg+xml' || type === 'text/plain')) {
            throw new Error("Invalid content type: " + type);
          }
        }

        if (httpRequest.readyState === 4) {
          if (httpRequest.status === 404 || httpRequest.responseXML === null) {
            throw new Error(isLocal() ? 'Note: SVG injection ajax calls do not work locally without ' + 'adjusting security settings in your browser. Or consider ' + 'using a local webserver.' : 'Unable to load SVG file: ' + url);
          }

          if (httpRequest.status === 200 || isLocal() && httpRequest.status === 0) {
            callback(null, httpRequest);
          } else {
            throw new Error('There was a problem injecting the SVG: ' + httpRequest.status + ' ' + httpRequest.statusText);
          }
        }
      } catch (error) {
        httpRequest.abort();
        callback(error, httpRequest);
      }
    };

    httpRequest.open('GET', url);

    if (httpRequest.overrideMimeType) {
      httpRequest.overrideMimeType('text/xml');
    }

    httpRequest.send();
  };

  var svgCache = new Map();

  var requestQueue = {};
  var queueRequest = function queueRequest(url, callback) {
    requestQueue[url] = requestQueue[url] || [];
    requestQueue[url].push(callback);
  };
  var processRequestQueue = function processRequestQueue(url) {
    var _loop_1 = function _loop_1(i, len) {
      setTimeout(function () {
        if (Array.isArray(requestQueue[url])) {
          var cacheValue = svgCache.get(url);
          var callback = requestQueue[url][i];

          if (cacheValue instanceof SVGElement) {
            callback(null, cloneSvg(cacheValue));
          }

          if (cacheValue instanceof Error) {
            callback(cacheValue);
          }

          if (i === requestQueue[url].length - 1) {
            delete requestQueue[url];
          }
        }
      }, 0);
    };

    for (var i = 0, len = requestQueue[url].length; i < len; i++) {
      _loop_1(i);
    }
  };

  var loadSvgCached = function loadSvgCached(url, callback) {
    if (svgCache.has(url)) {
      var cacheValue = svgCache.get(url);

      if (cacheValue instanceof SVGElement) {
        callback(null, cloneSvg(cacheValue));
        return;
      }

      if (cacheValue instanceof Error) {
        callback(cacheValue);
        return;
      }

      queueRequest(url, callback);
      return;
    }

    svgCache.set(url, undefined);
    queueRequest(url, callback);
    makeAjaxRequest(url, function (error, httpRequest) {
      if (error) {
        svgCache.set(url, error);
      } else if (httpRequest.responseXML instanceof Document && httpRequest.responseXML.documentElement && httpRequest.responseXML.documentElement instanceof SVGElement) {
        svgCache.set(url, httpRequest.responseXML.documentElement);
      }

      processRequestQueue(url);
    });
  };

  var loadSvgUncached = function loadSvgUncached(url, callback) {
    makeAjaxRequest(url, function (error, httpRequest) {
      if (error) {
        callback(error);
      } else if (httpRequest.responseXML instanceof Document && httpRequest.responseXML.documentElement && httpRequest.responseXML.documentElement instanceof SVGElement) {
        callback(null, httpRequest.responseXML.documentElement);
      }
    });
  };

  var idCounter = 0;

  var uniqueId = function uniqueId() {
    return ++idCounter;
  };

  var injectedElements = [];
  var ranScripts = {};
  var svgNamespace = 'http://www.w3.org/2000/svg';
  var xlinkNamespace = 'http://www.w3.org/1999/xlink';

  var injectElement = function injectElement(el, evalScripts, renumerateIRIElements, cacheRequests, beforeEach, callback) {
    var imgUrl = el.getAttribute('data-src') || el.getAttribute('src');

    if (!imgUrl) {
      callback(new Error('Invalid data-src or src attribute'));
      return;
    }

    if (injectedElements.indexOf(el) !== -1) {
      injectedElements.splice(injectedElements.indexOf(el), 1);
      el = null;
      return;
    }

    injectedElements.push(el);
    el.setAttribute('src', '');
    var loadSvg = cacheRequests ? loadSvgCached : loadSvgUncached;
    loadSvg(imgUrl, function (error, svg) {
      if (!svg) {
        injectedElements.splice(injectedElements.indexOf(el), 1);
        el = null;
        callback(error);
        return;
      }

      var imgId = el.getAttribute('id');

      if (imgId) {
        svg.setAttribute('id', imgId);
      }

      var imgTitle = el.getAttribute('title');

      if (imgTitle) {
        svg.setAttribute('title', imgTitle);
      }

      var imgWidth = el.getAttribute('width');

      if (imgWidth) {
        svg.setAttribute('width', imgWidth);
      }

      var imgHeight = el.getAttribute('height');

      if (imgHeight) {
        svg.setAttribute('height', imgHeight);
      }

      var mergedClasses = Array.from(new Set(__spreadArrays((svg.getAttribute('class') || '').split(' '), ['injected-svg'], (el.getAttribute('class') || '').split(' ')))).join(' ').trim();
      svg.setAttribute('class', mergedClasses);
      var imgStyle = el.getAttribute('style');

      if (imgStyle) {
        svg.setAttribute('style', imgStyle);
      }

      svg.setAttribute('data-src', imgUrl);
      var imgData = [].filter.call(el.attributes, function (at) {
        return /^data-\w[\w-]*$/.test(at.name);
      });
      Array.prototype.forEach.call(imgData, function (dataAttr) {
        if (dataAttr.name && dataAttr.value) {
          svg.setAttribute(dataAttr.name, dataAttr.value);
        }
      });

      if (renumerateIRIElements) {
        var iriElementsAndProperties_1 = {
          clipPath: ['clip-path'],
          'color-profile': ['color-profile'],
          cursor: ['cursor'],
          filter: ['filter'],
          linearGradient: ['fill', 'stroke'],
          marker: ['marker', 'marker-start', 'marker-mid', 'marker-end'],
          mask: ['mask'],
          path: [],
          pattern: ['fill', 'stroke'],
          radialGradient: ['fill', 'stroke']
        };
        var element_1;
        var elements_1;
        var properties_1;
        var currentId_1;
        var newId_1;
        Object.keys(iriElementsAndProperties_1).forEach(function (key) {
          element_1 = key;
          properties_1 = iriElementsAndProperties_1[key];
          elements_1 = svg.querySelectorAll(element_1 + '[id]');

          var _loop_1 = function _loop_1(a, elementsLen) {
            currentId_1 = elements_1[a].id;
            newId_1 = currentId_1 + '-' + uniqueId();
            var referencingElements;
            Array.prototype.forEach.call(properties_1, function (property) {
              referencingElements = svg.querySelectorAll('[' + property + '*="' + currentId_1 + '"]');

              for (var b = 0, referencingElementLen = referencingElements.length; b < referencingElementLen; b++) {
                var attrValue = referencingElements[b].getAttribute(property);

                if (attrValue && !attrValue.match(new RegExp('url\\("?#' + currentId_1 + '"?\\)'))) {
                  continue;
                }

                referencingElements[b].setAttribute(property, 'url(#' + newId_1 + ')');
              }
            });
            var allLinks = svg.querySelectorAll('[*|href]');
            var links = [];

            for (var c = 0, allLinksLen = allLinks.length; c < allLinksLen; c++) {
              var href = allLinks[c].getAttributeNS(xlinkNamespace, 'href');

              if (href && href.toString() === '#' + elements_1[a].id) {
                links.push(allLinks[c]);
              }
            }

            for (var d = 0, linksLen = links.length; d < linksLen; d++) {
              links[d].setAttributeNS(xlinkNamespace, 'href', '#' + newId_1);
            }

            elements_1[a].id = newId_1;
          };

          for (var a = 0, elementsLen = elements_1.length; a < elementsLen; a++) {
            _loop_1(a);
          }
        });
      }

      svg.removeAttribute('xmlns:a');
      var scripts = svg.querySelectorAll('script');
      var scriptsToEval = [];
      var script;
      var scriptType;

      for (var i = 0, scriptsLen = scripts.length; i < scriptsLen; i++) {
        scriptType = scripts[i].getAttribute('type');

        if (!scriptType || scriptType === 'application/ecmascript' || scriptType === 'application/javascript' || scriptType === 'text/javascript') {
          script = scripts[i].innerText || scripts[i].textContent;

          if (script) {
            scriptsToEval.push(script);
          }

          svg.removeChild(scripts[i]);
        }
      }

      if (scriptsToEval.length > 0 && (evalScripts === 'always' || evalScripts === 'once' && !ranScripts[imgUrl])) {
        for (var l = 0, scriptsToEvalLen = scriptsToEval.length; l < scriptsToEvalLen; l++) {
          new Function(scriptsToEval[l])(window);
        }

        ranScripts[imgUrl] = true;
      }

      var styleTags = svg.querySelectorAll('style');
      Array.prototype.forEach.call(styleTags, function (styleTag) {
        styleTag.textContent += '';
      });
      svg.setAttribute('xmlns', svgNamespace);
      svg.setAttribute('xmlns:xlink', xlinkNamespace);
      beforeEach(svg);

      if (el.parentNode) {
        el.parentNode.replaceChild(svg, el);
      }

      injectedElements.splice(injectedElements.indexOf(el), 1);
      el = null;
      callback(null, svg);
    });
  };

  var SVGInjector = function SVGInjector(elements, _a) {
    var _b = _a === void 0 ? {} : _a,
        _c = _b.afterAll,
        afterAll = _c === void 0 ? function () {
      return undefined;
    } : _c,
        _d = _b.afterEach,
        afterEach = _d === void 0 ? function () {
      return undefined;
    } : _d,
        _e = _b.beforeEach,
        beforeEach = _e === void 0 ? function () {
      return undefined;
    } : _e,
        _f = _b.cacheRequests,
        cacheRequests = _f === void 0 ? true : _f,
        _g = _b.evalScripts,
        evalScripts = _g === void 0 ? 'never' : _g,
        _h = _b.renumerateIRIElements,
        renumerateIRIElements = _h === void 0 ? true : _h;

    if (elements && 'length' in elements) {
      var elementsLoaded_1 = 0;

      for (var i = 0, j = elements.length; i < j; i++) {
        injectElement(elements[i], evalScripts, renumerateIRIElements, cacheRequests, beforeEach, function (error, svg) {
          afterEach(error, svg);

          if (elements && 'length' in elements && elements.length === ++elementsLoaded_1) {
            afterAll(elementsLoaded_1);
          }
        });
      }
    } else if (elements) {
      injectElement(elements, evalScripts, renumerateIRIElements, cacheRequests, beforeEach, function (error, svg) {
        afterEach(error, svg);
        afterAll(1);
        elements = null;
      });
    } else {
      afterAll(0);
    }
  };

  // Hat-tip: https://github.com/developit/preact-compat/blob/master/src/index.js#L402.
  var shallowDiffers = function shallowDiffers(a, b) {
    for (var i in a) {
      if (!(i in b)) {
        return true;
      }
    }

    for (var _i in b) {
      if (a[_i] !== b[_i]) {
        return true;
      }
    }

    return false;
  };

  var ReactSVG = /*#__PURE__*/function (_React$Component) {
    inheritsLoose(ReactSVG, _React$Component);

    function ReactSVG() {
      var _this;

      _this = _React$Component.apply(this, arguments) || this;
      _this.initialState = {
        hasError: false,
        isLoading: true
      };
      _this.state = _this.initialState;
      _this._isMounted = false;

      _this.refCallback = function (container) {
        _this.container = container;
      };

      return _this;
    }

    var _proto = ReactSVG.prototype;

    _proto.renderSVG = function renderSVG() {
      var _this2 = this;

      /* istanbul ignore else */
      if (this.container instanceof Node) {
        var _this$props = this.props,
            beforeInjection = _this$props.beforeInjection,
            evalScripts = _this$props.evalScripts,
            renumerateIRIElements = _this$props.renumerateIRIElements,
            src = _this$props.src,
            useRequestCache = _this$props.useRequestCache;
        /* eslint-disable @typescript-eslint/no-non-null-assertion */

        var afterInjection = this.props.afterInjection;
        var Wrapper = this.props.wrapper;
        /* eslint-enable @typescript-eslint/no-non-null-assertion */

        var wrapper = document.createElement(Wrapper);
        wrapper.innerHTML = ReactDOMServer__default['default'].renderToStaticMarkup( /*#__PURE__*/React.createElement(Wrapper, null, /*#__PURE__*/React.createElement(Wrapper, {
          "data-src": src
        })));
        this.svgWrapper = this.container.appendChild(wrapper.firstChild);

        var afterEach = function afterEach(error, svg) {
          if (error) {
            _this2.removeSVG();
          } // TODO: It'd be better to cleanly unsubscribe from SVGInjector
          // callbacks instead of tracking a property like this.


          if (_this2._isMounted) {
            _this2.setState(function () {
              return {
                hasError: !!error,
                isLoading: false
              };
            }, function () {
              afterInjection(error, svg);
            });
          }
        };

        SVGInjector(this.svgWrapper.firstChild, {
          afterEach: afterEach,
          beforeEach: beforeInjection,
          cacheRequests: useRequestCache,
          evalScripts: evalScripts,
          renumerateIRIElements: renumerateIRIElements
        });
      }
    };

    _proto.removeSVG = function removeSVG() {
      if (this.container instanceof Node && this.svgWrapper instanceof Node) {
        this.container.removeChild(this.svgWrapper);
        this.svgWrapper = null;
      }
    };

    _proto.componentDidMount = function componentDidMount() {
      this._isMounted = true;
      this.renderSVG();
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var _this3 = this;

      if (shallowDiffers(prevProps, this.props)) {
        this.setState(function () {
          return _this3.initialState;
        }, function () {
          _this3.removeSVG();

          _this3.renderSVG();
        });
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this._isMounted = false;
      this.removeSVG();
    };

    _proto.render = function render() {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      var _this$props2 = this.props,
          afterInjection = _this$props2.afterInjection,
          beforeInjection = _this$props2.beforeInjection,
          evalScripts = _this$props2.evalScripts,
          Fallback = _this$props2.fallback,
          Loading = _this$props2.loading,
          renumerateIRIElements = _this$props2.renumerateIRIElements,
          src = _this$props2.src,
          useRequestCache = _this$props2.useRequestCache,
          wrapper = _this$props2.wrapper,
          rest = objectWithoutPropertiesLoose(_this$props2, ["afterInjection", "beforeInjection", "evalScripts", "fallback", "loading", "renumerateIRIElements", "src", "useRequestCache", "wrapper"]);
      /* eslint-enable @typescript-eslint/no-unused-vars */
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


      var Wrapper = wrapper;
      return /*#__PURE__*/React.createElement(Wrapper, Object.assign({}, rest, {
        ref: this.refCallback
      }), this.state.isLoading && Loading && /*#__PURE__*/React.createElement(Loading, null), this.state.hasError && Fallback && /*#__PURE__*/React.createElement(Fallback, null));
    };

    return ReactSVG;
  }(React.Component);
  ReactSVG.defaultProps = {
    afterInjection: function afterInjection() {
      return undefined;
    },
    beforeInjection: function beforeInjection() {
      return undefined;
    },
    evalScripts: 'never',
    fallback: null,
    loading: null,
    renumerateIRIElements: true,
    useRequestCache: true,
    wrapper: 'div'
  };
  ReactSVG.propTypes = {
    afterInjection: PropTypes.func,
    beforeInjection: PropTypes.func,
    evalScripts: PropTypes.oneOf(['always', 'once', 'never']),
    fallback: PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.string]),
    loading: PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.string]),
    renumerateIRIElements: PropTypes.bool,
    src: PropTypes.string.isRequired,
    useRequestCache: PropTypes.bool,
    wrapper: PropTypes.oneOf(['div', 'span'])
  };

  exports.ReactSVG = ReactSVG;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-svg.umd.development.js.map
